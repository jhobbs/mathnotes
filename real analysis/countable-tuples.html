<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Countable n-tuples Visualization</title>
    <link rel="stylesheet" href="/static/demo-style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="/static/demo-dark-mode.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        #canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        #info {
            text-align: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="sketch-holder"></div>
        <div id="info">
            <h2>Countable n-tuples from Countable Set</h2>
            <p>This animation illustrates the proof that B_n (the set of all n-tuples from a countable set A) is countable for any n.</p>
        </div>
    </div>

    <script>
        let canvasWidth;
        let canvasHeight;
        let centerY;
        let columnSpacing = 180;
        let circleRadius = 20;
        let verticalSpacing = 40;
        let smallCircleRadius = 12;
        let animationStartTime;
        let showA = false;
        let showB1 = false;
        let showB2 = false;
        let showB3 = false;
        let showB4 = false;
        let shiftLeft = false;
        
        function setup() {
            canvasWidth = min(windowWidth - 40, 1200);
            canvasHeight = min(windowHeight - 200, 800);
            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('sketch-holder');
            
            centerY = canvasHeight / 2;
            
            textAlign(CENTER, CENTER);
            strokeWeight(2);
            
            // Start animation timer
            animationStartTime = millis();
        }
        
        function draw() {
            background(getBackgroundColor());
            
            // Configuration - easily adjustable
            let maxColumns = 6; // A, B₁, B₂, B₃, B₄, B₅ (can be easily increased)
            let stepDuration = 2000; // Time between each column appearing
            let shiftDelay = 1000; // Extra delay before shifting starts
            let colSpacing = 200;
            let startX = 100;
            
            // Update animation state based on elapsed time
            let elapsed = millis() - animationStartTime;
            let cycleTime = maxColumns * stepDuration + shiftDelay + 2000; // Total cycle time
            elapsed = elapsed % cycleTime; // Loop animation
            
            // Calculate which columns should be visible
            let visibleColumns = [];
            for (let i = 0; i < maxColumns; i++) {
                if (elapsed >= i * stepDuration) {
                    visibleColumns.push(i);
                }
            }
            
            // Calculate shift
            let shiftStartTime = (maxColumns - 1) * stepDuration + shiftDelay;
            let shift = elapsed >= shiftStartTime ? -colSpacing : 0;
            
            // Draw columns and connections
            for (let i = 0; i < visibleColumns.length; i++) {
                let colIndex = visibleColumns[i];
                let x = startX + colIndex * colSpacing + shift;
                
                // Special handling for the last column when shifting
                if (elapsed >= shiftStartTime && colIndex === maxColumns - 1) {
                    x = startX + (maxColumns - 1) * colSpacing; // Keep rightmost position
                }
                
                // Draw the column
                if (colIndex === 0) {
                    // Draw set A
                    drawIntegerColumn(x, 'A', -5, 5);
                } else {
                    // Draw B_n
                    drawBnColumn(x, colIndex);
                }
                
                // Draw connection from previous column (if not the first column)
                if (colIndex > 0 && i > 0) {
                    let prevColIndex = visibleColumns[i - 1];
                    let prevX = startX + prevColIndex * colSpacing + shift;
                    
                    // Special handling for shift phase
                    if (elapsed >= shiftStartTime) {
                        if (prevColIndex === maxColumns - 2) {
                            // Previous column is shifting, current is stationary
                            prevX = startX + prevColIndex * colSpacing + shift;
                            x = startX + (maxColumns - 1) * colSpacing;
                        }
                    }
                    
                    // Draw arrows between columns
                    if (colIndex === 1) {
                        // A to B₁ - A is level 0, B₁ is level 1
                        drawArrowsBetweenColumns(prevX, x, 0, colIndex, -5, 5);
                    } else {
                        // B_n to B_{n+1}
                        drawArrowsBetweenColumns(prevX, x, colIndex - 1, colIndex, -5, 5);
                    }
                    
                    // Draw cardinality label on dividing line
                    let lineX = (prevX + x) / 2;
                    stroke(getStrokeColor());
                    strokeWeight(2);
                    line(lineX, 100, lineX, canvasHeight - 100);
                    
                    // Draw |A|^n label
                    fill(getBackgroundColor());
                    noStroke();
                    let labelWidth = colIndex === 1 ? 40 : 50;
                    rect(lineX - labelWidth/2, centerY - 20, labelWidth, 40);
                    fill(getTextColor());
                    textSize(colIndex === 1 ? 24 : 22);
                    
                    let label = '|A|';
                    if (colIndex > 1) {
                        label += getSuperscriptUnicode(colIndex);
                    }
                    text(label, lineX, centerY);
                }
            }
        }
        
        function getSuperscriptUnicode(n) {
            const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹'];
            return n.toString().split('').map(d => superscripts[parseInt(d)]).join('');
        }
        
        function drawIntegerColumn(x, label, minVal, maxVal) {
            // Draw column label
            fill(getTextColor());
            noStroke();
            textSize(28);
            textStyle(BOLD);
            text(label, x, 60);
            textStyle(NORMAL);
            
            // Draw integers in circles
            for (let i = minVal; i <= maxVal; i++) {
                let y = centerY + i * verticalSpacing;
                
                // Draw circle
                stroke(getStrokeColor());
                strokeWeight(2);
                fill(getBackgroundColor());
                circle(x, y, circleRadius * 2);
                
                // Draw number
                fill(getTextColor());
                noStroke();
                textSize(18);
                text(i, x, y);
            }
            
            // Draw ellipsis and arrows for infinity
            fill(getTextColor());
            noStroke();
            textSize(24);
            
            // Top ellipsis and arrow
            let topY = centerY + minVal * verticalSpacing;
            text('⋮', x, topY - 50);
            textSize(20);
            text('↑ ∞', x, topY - 80);
            
            // Bottom ellipsis and arrow
            textSize(24);
            let bottomY = centerY + maxVal * verticalSpacing;
            text('⋮', x, bottomY + 50);
            textSize(20);
            text('↓ ∞', x, bottomY + 80);
        }
        
        function drawArrows(x1, x2, minVal, maxVal) {
            stroke(getStrokeColor());
            strokeWeight(1);
            
            // Draw an arrow from each element in A to the corresponding element in B_1
            for (let i = minVal; i <= maxVal; i++) {
                let y = centerY + i * verticalSpacing;
                
                // Draw arrow line
                stroke(getStrokeColor());
                strokeWeight(1);
                drawingContext.setLineDash([3, 3]);
                line(x1 + circleRadius, y, x2 - circleRadius, y);
                drawingContext.setLineDash([]);
                
                // Draw arrowhead
                strokeWeight(2);
                line(x2 - circleRadius, y, x2 - circleRadius - 8, y - 4);
                line(x2 - circleRadius, y, x2 - circleRadius - 8, y + 4);
            }
        }
        
        function drawBnColumn(x, n) {
            // Draw column label
            fill(getTextColor());
            noStroke();
            textSize(28);
            textStyle(BOLD);
            text(`B${getSubscriptUnicode(n)}`, x, 60);
            textStyle(NORMAL);
            
            // B₁ is just like A - simple integers
            if (n === 1) {
                drawIntegerColumn(x, `B${getSubscriptUnicode(n)}`, -5, 5);
                return;
            }
            
            // Parameters that change based on n
            let nodeRadius = Math.max(4, 20 - (n - 1) * 4); // Smaller circles for higher n
            let textSz = Math.max(4, 16 - (n - 1) * 2); // Smaller text for higher n
            let density = Math.min(n, 4); // How many sub-elements to show
            let jitter = Math.min(n - 1, 3); // How much variation in positioning
            
            // Generate sample elements from previous level
            let sampleElements = generateSampleElements(n - 1, Math.min(11, 5 + n * 2));
            
            // Show n-tuples
            for (let i = 0; i < sampleElements.length; i++) {
                let elem = sampleElements[i];
                let baseY = getElementY(elem, n - 1, i, sampleElements.length);
                
                // Draw ellipsis above and below if not too dense
                if (n <= 3) {
                    fill(getTextColor());
                    noStroke();
                    textSize(14);
                    text('⋮', x, baseY - 30);
                    text('⋮', x, baseY + 30);
                }
                
                // Draw the sub-elements for this n-tuple
                let subElements = [-Math.floor(density/2), -Math.floor(density/2) + 1, 0, Math.floor(density/2) - 1, Math.floor(density/2)].slice(0, density);
                for (let j = 0; j < subElements.length; j++) {
                    let spacing = Math.max(6, 20 - (n - 2) * 3);
                    let y = baseY + (j - Math.floor(density/2)) * spacing + (i % jitter) * 2;
                    let xOffset = (j % 2) * Math.min(15, 25 - n * 2) - Math.min(7.5, 12.5 - n);
                    
                    // Only draw if within reasonable bounds
                    if (y > 90 && y < canvasHeight - 90 && Math.abs(xOffset) < 30) {
                        // Draw circle
                        stroke(getStrokeColor());
                        strokeWeight(Math.max(0.2, 1.5 - (n - 2) * 0.3));
                        fill(getBackgroundColor());
                        circle(x + xOffset, y, nodeRadius * 2);
                        
                        // Draw n-tuple notation
                        fill(getTextColor());
                        noStroke();
                        textSize(textSz);
                        let tupleStr = generateTupleString(elem, subElements[j]);
                        text(tupleStr, x + xOffset, y);
                    }
                }
            }
            
            // Add ellipsis to show density for higher n
            if (n >= 3) {
                fill(getTextColor());
                noStroke();
                textSize(Math.max(16, 32 - n * 2));
                text('⋮', x, 85);
                text('⋮', x, canvasHeight - 85);
                if (n >= 4) {
                    text('⋮', x - 25, centerY - 50);
                    text('⋮', x + 25, centerY - 50);
                    text('⋮', x - 25, centerY + 50);
                    text('⋮', x + 25, centerY + 50);
                    text('⋮', x, centerY);
                }
            }
        }
        
        function getSubscriptUnicode(n) {
            const subscripts = ['₀', '₁', '₂', '₃', '₄', '₅', '₆', '₇', '₈', '₉'];
            return n.toString().split('').map(d => subscripts[parseInt(d)]).join('');
        }
        
        function generateSampleElements(level, count) {
            if (level === 1) {
                // For level 1 (A to B₂), just return integers
                let result = [];
                for (let i = -Math.floor(count/2); i <= Math.floor(count/2); i++) {
                    result.push([i]);
                }
                return result;
            }
            
            // For higher levels, generate sample tuples iteratively to avoid stack overflow
            let result = [];
            let baseValues = [-2, -1, 0, 1, 2];
            
            // Simple iterative approach for small tuples
            if (level === 2) {
                for (let i = 0; i < baseValues.length && result.length < count; i++) {
                    for (let j = 0; j < baseValues.length && result.length < count; j++) {
                        result.push([baseValues[i], baseValues[j]]);
                    }
                }
            } else if (level === 3) {
                for (let i = 0; i < baseValues.length && result.length < count; i++) {
                    for (let j = 0; j < baseValues.length && result.length < count; j++) {
                        for (let k = 0; k < baseValues.length && result.length < count; k++) {
                            result.push([baseValues[i], baseValues[j], baseValues[k]]);
                        }
                    }
                }
            } else {
                // For higher levels, use a simpler approach
                for (let i = 0; i < count; i++) {
                    let tuple = [];
                    for (let j = 0; j < level; j++) {
                        tuple.push(baseValues[i % baseValues.length]);
                    }
                    result.push(tuple);
                }
            }
            
            return result.slice(0, count);
        }
        
        function getElementY(element, level, elementIndex, totalElements) {
            // Distribute elements evenly across the full vertical space
            // Same range as the A column: from top to bottom
            let minVal = -5;
            let maxVal = 5;
            let availableHeight = (maxVal - minVal) * verticalSpacing;
            let topY = centerY + minVal * verticalSpacing;
            
            if (totalElements <= 1) {
                return centerY;
            }
            
            // Spread elements evenly across the available height
            let spacing = availableHeight / (totalElements - 1);
            return topY + elementIndex * spacing;
        }
        
        function generateTupleString(baseElement, lastValue) {
            let values = [...baseElement, lastValue];
            return `(${values.join(',')})`;
        }
        
        function drawArrowsBetweenColumns(x1, x2, fromLevel, toLevel, minVal, maxVal) {
            stroke(getStrokeColor());
            
            // Arrow parameters based on levels
            let strokeWt = Math.max(0.1, 1.0 - (toLevel - 2) * 0.2);
            let dashSize = Math.max(1, 3 - toLevel * 0.5);
            strokeWeight(strokeWt);
            drawingContext.setLineDash([dashSize, dashSize * 2]);
            
            // General case: handle all connections from any level to next level
            let sourceElements;
            if (fromLevel === 0) {
                // For A → B₁, use simple integers
                sourceElements = [];
                for (let i = minVal; i <= maxVal; i++) {
                    sourceElements.push([i]);
                }
            } else {
                // For B_n → B_{n+1}, generate sample elements
                sourceElements = generateSampleElements(fromLevel, Math.min(11, 5 + fromLevel * 2));
            }
            
            // Density should reflect the mathematical relationship:
            // A → B₁: 1 arrow (1-to-1)
            // B₁ → B₂: ~3-5 arrows (1-to-many, showing some 2-tuples)
            // B₂ → B₃: ~4-6 arrows (1-to-many, showing some 3-tuples)
            let density;
            if (fromLevel === 0) { // A → B₁
                density = 1;
            } else { // B_n → B_{n+1}
                density = Math.min(3 + fromLevel, 6); // Grows with level
            }
            
            let spreadFactor = Math.min(toLevel * 10, 60); // How much arrows spread out
            
            for (let i = 0; i < sourceElements.length; i++) {
                let sourceElem = sourceElements[i];
                let y1;
                
                if (fromLevel === 0) {
                    // For A elements, use simple integer positioning
                    y1 = centerY + sourceElem[0] * verticalSpacing;
                } else {
                    // For B_n elements, use complex positioning
                    y1 = getElementY(sourceElem, fromLevel, i, sourceElements.length);
                }
                
                // Skip if source is outside visible area
                if (y1 < 100 || y1 > canvasHeight - 100) continue;
                
                let sourceRadius = fromLevel === 0 ? circleRadius : Math.max(4, 20 - fromLevel * 4);
                
                // Draw arrows to target elements
                for (let j = 0; j < density; j++) {
                    let targetOffset = (j - Math.floor(density/2)) * Math.max(6, 20 - Math.max(0, toLevel - 2) * 3);
                    let y2 = y1 + targetOffset + (i % 3) * 2; // Add some jitter
                    let xOffset = (j % 2) * Math.min(15, 25 - toLevel * 2) - Math.min(7.5, 12.5 - toLevel);
                    let targetRadius = toLevel === 1 ? circleRadius : Math.max(4, 20 - (toLevel - 1) * 4);
                    
                    if (y2 > 100 && y2 < canvasHeight - 100) {
                        line(x1 + sourceRadius, y1, x2 + xOffset - targetRadius, y2);
                    }
                }
                
                // Add some arrows going off-screen to show density (starts from level 2)
                if (toLevel >= 2 && i % Math.max(1, 4 - toLevel) === 0) {
                    for (let spread = -spreadFactor; spread <= spreadFactor; spread += spreadFactor/3) {
                        let targetY = y1 + spread;
                        if (targetY > 50 && targetY < canvasHeight - 50) {
                            line(x1 + sourceRadius, y1, canvasWidth - 5, targetY);
                        }
                    }
                }
            }
            
            drawingContext.setLineDash([]);
        }
        
        
        
        function windowResized() {
            canvasWidth = min(windowWidth - 40, 1200);
            canvasHeight = min(windowHeight - 200, 800);
            resizeCanvas(canvasWidth, canvasHeight);
            centerY = canvasHeight / 2;
        }
    </script>
</body>
</html>