<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Countable n-tuples Visualization</title>
    <link rel="stylesheet" href="/static/demo-style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="/static/demo-dark-mode.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        #canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        #info {
            text-align: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="sketch-holder"></div>
        <div id="info">
            <h2>Countable n-tuples from Countable Set</h2>
            <p>This animation illustrates the proof that B_n (the set of all n-tuples from a countable set A) is countable for any n.</p>
        </div>
    </div>

    <script>
        let canvasWidth;
        let canvasHeight;
        let centerY;
        let columnSpacing = 180;
        let circleRadius = 20;
        let verticalSpacing = 40;
        let smallCircleRadius = 12;
        let animationStartTime;
        let showA = false;
        let showB1 = false;
        let showB2 = false;
        let showB3 = false;
        let showB4 = false;
        let shiftLeft = false;
        
        function setup() {
            canvasWidth = min(windowWidth - 40, 1200);
            canvasHeight = min(windowHeight - 200, 800);
            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('sketch-holder');
            
            centerY = canvasHeight / 2;
            
            textAlign(CENTER, CENTER);
            strokeWeight(2);
            
            // Start animation timer
            animationStartTime = millis();
        }
        
        function draw() {
            background(getBackgroundColor());
            
            // Update animation state based on elapsed time
            let elapsed = millis() - animationStartTime;
            let cycleTime = 10000; // 10 seconds total cycle
            elapsed = elapsed % cycleTime; // Loop animation
            
            showA = elapsed >= 0;
            showB1 = elapsed >= 2000;
            showB2 = elapsed >= 4000;
            showB3 = elapsed >= 6000;
            shiftLeft = elapsed >= 8000;
            showB4 = elapsed >= 8000;
            
            // Define 4 equally spaced column positions (shifted left to center better)
            let col1 = 100;
            let col2 = 300; 
            let col3 = 500;
            let col4 = 700;
            let colSpacing = 200;
            
            // Calculate shift offset - each column moves one position left
            let shift = shiftLeft ? -colSpacing : 0;
            
            // Draw set A (column 1)
            if (showA) {
                drawIntegerColumn(col1 + shift, 'A', -5, 5);
            }
            
            // Draw first connection and B_1
            if (showB1) {
                // Draw arrows from A to B_1
                drawArrows(col1 + shift, col2 + shift, -5, 5);
                
                // Draw first vertical dividing line
                let lineX = col1 + (colSpacing / 2) + shift;
                stroke(getStrokeColor());
                strokeWeight(2);
                line(lineX, 100, lineX, canvasHeight - 100);
                
                // Draw |A| label over the first dividing line
                fill(getBackgroundColor());
                noStroke();
                rect(lineX - 20, centerY - 20, 40, 40);
                fill(getTextColor());
                textSize(24);
                text('|A|', lineX, centerY);
                
                // Draw set B_1 (column 2)
                drawIntegerColumn(col2 + shift, 'B₁', -5, 5);
            }
            
            // Draw second connection and B_2
            if (showB2) {
                // Draw arrows from B_1 to B_2
                drawArrowsToB2(col2 + shift, col3 + shift, -5, 5);
                
                // Draw second vertical dividing line
                let lineX = col2 + (colSpacing / 2) + shift;
                stroke(getStrokeColor());
                strokeWeight(2);
                line(lineX, 100, lineX, canvasHeight - 100);
                
                // Draw |A|² label over the second dividing line
                fill(getBackgroundColor());
                noStroke();
                rect(lineX - 25, centerY - 20, 50, 40);
                fill(getTextColor());
                textSize(22);
                text('|A|²', lineX, centerY);
                
                // Draw set B_2 (column 3)
                drawB2Column(col3 + shift);
            }
            
            // Draw third connection and B_3
            if (showB3) {
                // Draw arrows from B_2 to B_3
                drawArrowsToB3(col3 + shift, col4 + shift);
                
                // Draw third vertical dividing line
                let lineX = col3 + (colSpacing / 2) + shift;
                stroke(getStrokeColor());
                strokeWeight(2);
                line(lineX, 100, lineX, canvasHeight - 100);
                
                // Draw |A|³ label over the third dividing line
                fill(getBackgroundColor());
                noStroke();
                rect(lineX - 25, centerY - 20, 50, 40);
                fill(getTextColor());
                textSize(22);
                text('|A|³', lineX, centerY);
                
                // Draw set B_3 (column 4)
                drawB3Column(col4 + shift);
            }
            
            // Draw fourth connection and B_4
            if (showB4) {
                console.log('Drawing B4, showB4:', showB4, 'shift:', shift);
                
                // B_3 is drawn at col4 + shift, B_4 at col4
                let b3Position = col4 + shift;
                let b4Position = col4;
                
                // Draw arrows from B_3 to B_4
                drawArrowsToB4(b3Position, b4Position);
                
                // Draw fourth vertical dividing line (between shifted B_3 and B_4)
                let lineX = (b3Position + b4Position) / 2; // Midpoint between B_3 and B_4
                console.log('B3 position:', b3Position, 'B4 position:', col4, 'Line X:', lineX);
                
                stroke(getStrokeColor());
                strokeWeight(2);
                line(lineX, 100, lineX, canvasHeight - 100);
                
                // Draw set B_4 at the rightmost position
                drawB4Column(col4);
                
                // Draw |A|⁴ label AFTER everything else so it's on top
                fill(getBackgroundColor());
                noStroke();
                rect(lineX - 25, centerY - 20, 50, 40);
                fill(getTextColor());
                textSize(22);
                text('|A|⁴', lineX, centerY);
                console.log('Drew |A|⁴ label at:', lineX, centerY);
            }
        }
        
        function drawIntegerColumn(x, label, minVal, maxVal) {
            // Draw column label
            fill(getTextColor());
            noStroke();
            textSize(28);
            textStyle(BOLD);
            text(label, x, 60);
            textStyle(NORMAL);
            
            // Draw integers in circles
            for (let i = minVal; i <= maxVal; i++) {
                let y = centerY + i * verticalSpacing;
                
                // Draw circle
                stroke(getStrokeColor());
                strokeWeight(2);
                fill(getBackgroundColor());
                circle(x, y, circleRadius * 2);
                
                // Draw number
                fill(getTextColor());
                noStroke();
                textSize(18);
                text(i, x, y);
            }
            
            // Draw ellipsis and arrows for infinity
            fill(getTextColor());
            noStroke();
            textSize(24);
            
            // Top ellipsis and arrow
            let topY = centerY + minVal * verticalSpacing;
            text('⋮', x, topY - 50);
            textSize(20);
            text('↑ ∞', x, topY - 80);
            
            // Bottom ellipsis and arrow
            textSize(24);
            let bottomY = centerY + maxVal * verticalSpacing;
            text('⋮', x, bottomY + 50);
            textSize(20);
            text('↓ ∞', x, bottomY + 80);
        }
        
        function drawArrows(x1, x2, minVal, maxVal) {
            stroke(getStrokeColor());
            strokeWeight(1);
            
            // Draw an arrow from each element in A to the corresponding element in B_1
            for (let i = minVal; i <= maxVal; i++) {
                let y = centerY + i * verticalSpacing;
                
                // Draw arrow line
                stroke(getStrokeColor());
                strokeWeight(1);
                drawingContext.setLineDash([3, 3]);
                line(x1 + circleRadius, y, x2 - circleRadius, y);
                drawingContext.setLineDash([]);
                
                // Draw arrowhead
                strokeWeight(2);
                line(x2 - circleRadius, y, x2 - circleRadius - 8, y - 4);
                line(x2 - circleRadius, y, x2 - circleRadius - 8, y + 4);
            }
        }
        
        function drawB2Column(x) {
            // Draw column label
            fill(getTextColor());
            noStroke();
            textSize(28);
            textStyle(BOLD);
            text('B₂', x, 60);
            textStyle(NORMAL);
            
            // Show elements for all visible B_1 elements
            let visibleElements = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5];
            let subElements = [-1, 0, 1]; // Show these 3 sub-elements for each
            
            textSize(14);
            for (let i = 0; i < visibleElements.length; i++) {
                let baseY = centerY + visibleElements[i] * verticalSpacing;
                
                // Draw ellipsis above first sub-element
                fill(getTextColor());
                noStroke();
                text('⋮', x, baseY - 30);
                
                // Draw the 3 sub-elements
                for (let j = 0; j < subElements.length; j++) {
                    let y = baseY + (j - 1) * 20; // Reduced spacing between sub-elements
                    
                    // Draw smaller circle
                    stroke(getStrokeColor());
                    strokeWeight(1);
                    fill(getBackgroundColor());
                    circle(x, y, smallCircleRadius * 2);
                    
                    // Draw tuple notation
                    fill(getTextColor());
                    noStroke();
                    textSize(12);
                    text(`(${visibleElements[i]},${subElements[j]})`, x, y);
                }
                
                // Draw ellipsis below last sub-element
                fill(getTextColor());
                noStroke();
                textSize(14);
                text('⋮', x, baseY + 30);
            }
        }
        
        function drawArrowsToB2(x1, x2, minVal, maxVal) {
            stroke(getStrokeColor());
            strokeWeight(0.5);
            drawingContext.setLineDash([2, 2]);
            
            // For visible elements, draw arrows to their visible children
            let visibleElements = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5];
            let subElements = [-1, 0, 1];
            
            for (let elem of visibleElements) {
                let y1 = centerY + elem * verticalSpacing;
                let baseY2 = centerY + elem * verticalSpacing;
                
                // Draw arrows to the 3 visible sub-elements
                for (let j = 0; j < subElements.length; j++) {
                    let y2 = baseY2 + (j - 1) * 20;
                    line(x1 + circleRadius, y1, x2 - smallCircleRadius, y2);
                }
                
                // Draw arrows going off-screen (up and down)
                // Up arrow
                line(x1 + circleRadius, y1, x2 - 30, baseY2 - 50);
                // Down arrow
                line(x1 + circleRadius, y1, x2 - 30, baseY2 + 50);
            }
            
            // For elements outside the visible ones, draw arrows going off-screen
            for (let i = minVal; i <= maxVal; i++) {
                if (!visibleElements.includes(i)) {
                    let y1 = centerY + i * verticalSpacing;
                    
                    // Draw multiple arrows spreading out
                    for (let offset = -40; offset <= 40; offset += 20) {
                        let targetY = centerY + i * verticalSpacing + offset;
                        if (i < -2) {
                            // Elements above middle section
                            targetY = max(50, targetY);
                        } else {
                            // Elements below middle section
                            targetY = min(canvasHeight - 50, targetY);
                        }
                        line(x1 + circleRadius, y1, canvasWidth - 20, targetY);
                    }
                }
            }
            
            drawingContext.setLineDash([]);
        }
        
        function drawB3Column(x) {
            // Draw column label
            fill(getTextColor());
            noStroke();
            textSize(28);
            textStyle(BOLD);
            text('B₃', x, 60);
            textStyle(NORMAL);
            
            // Show many more elements from B_3, allowing overlap
            // Sample from different B_2 elements
            let sampleB2Elements = [
                {base: -5, sub: -1}, {base: -5, sub: 0}, {base: -5, sub: 1},
                {base: -4, sub: -1}, {base: -4, sub: 0}, {base: -4, sub: 1},
                {base: -3, sub: -1}, {base: -3, sub: 0}, {base: -3, sub: 1},
                {base: -2, sub: -1}, {base: -2, sub: 0}, {base: -2, sub: 1},
                {base: -1, sub: -1}, {base: -1, sub: 0}, {base: -1, sub: 1},
                {base: 0, sub: -1}, {base: 0, sub: 0}, {base: 0, sub: 1},
                {base: 1, sub: -1}, {base: 1, sub: 0}, {base: 1, sub: 1},
                {base: 2, sub: -1}, {base: 2, sub: 0}, {base: 2, sub: 1},
                {base: 3, sub: -1}, {base: 3, sub: 0}, {base: 3, sub: 1},
                {base: 4, sub: -1}, {base: 4, sub: 0}, {base: 4, sub: 1},
                {base: 5, sub: -1}, {base: 5, sub: 0}, {base: 5, sub: 1}
            ];
            
            textSize(9);
            let nodeRadius = 8;
            
            // Draw nodes in a dense pattern
            for (let i = 0; i < sampleB2Elements.length; i++) {
                let elem = sampleB2Elements[i];
                let baseY = centerY + elem.base * verticalSpacing + elem.sub * 12;
                
                // Show 5 sub-elements for each, with overlap
                let subSubElements = [-2, -1, 0, 1, 2];
                for (let j = 0; j < subSubElements.length; j++) {
                    let y = baseY + j * 10 + (i % 3) * 3; // Add some jitter
                    let xOffset = (j % 2) * 15 - 7.5; // Stagger left and right
                    
                    // Draw tiny circle
                    stroke(getStrokeColor());
                    strokeWeight(0.5);
                    fill(getBackgroundColor());
                    circle(x + xOffset, y, nodeRadius * 2);
                    
                    // Draw 3-tuple notation
                    fill(getTextColor());
                    noStroke();
                    textSize(7);
                    text(`(${elem.base},${elem.sub},${subSubElements[j]})`, x + xOffset, y);
                }
            }
            
            // Add ellipsis at edges
            fill(getTextColor());
            noStroke();
            textSize(16);
            text('⋮', x, 90);
            text('⋮', x, canvasHeight - 90);
        }
        
        function drawArrowsToB3(x1, x2) {
            stroke(getStrokeColor());
            strokeWeight(0.2);
            drawingContext.setLineDash([1, 2]);
            
            // Draw arrows from each B_2 element to multiple B_3 elements
            let nodeRadius = 8;
            
            // From each visible B_2 element, draw arrows to its B_3 children
            for (let base = -5; base <= 5; base++) {
                for (let sub of [-1, 0, 1]) {
                    let y1 = centerY + base * verticalSpacing + sub * 20;
                    
                    // Draw arrows to several B_3 children
                    for (let k of [-2, -1, 0, 1, 2]) {
                        let y2 = centerY + base * verticalSpacing + sub * 12 + k * 10;
                        let xOffset = (k % 2) * 15 - 7.5;
                        
                        // Only draw if within reasonable bounds
                        if (y2 > 100 && y2 < canvasHeight - 100) {
                            line(x1 + smallCircleRadius, y1, x2 + xOffset - nodeRadius, y2);
                        }
                    }
                    
                    // Also draw some arrows going off-screen
                    if (base % 3 === 0) {
                        line(x1 + smallCircleRadius, y1, canvasWidth - 5, y1 - 40);
                        line(x1 + smallCircleRadius, y1, canvasWidth - 5, y1 + 40);
                    }
                }
            }
            
            drawingContext.setLineDash([]);
        }
        
        function drawB4Column(x) {
            // Draw column label
            fill(getTextColor());
            noStroke();
            textSize(28);
            textStyle(BOLD);
            text('B₄', x, 60);
            textStyle(NORMAL);
            
            // Show extremely dense packed elements from B_4
            // Many more B_3 elements as sources
            let sampleB3Elements = [
                {base: -5, sub1: -1, sub2: 0}, {base: -5, sub1: 0, sub2: 1}, {base: -5, sub1: 1, sub2: -1},
                {base: -4, sub1: -1, sub2: 0}, {base: -4, sub1: 0, sub2: 1}, {base: -4, sub1: 1, sub2: -1},
                {base: -3, sub1: -1, sub2: 0}, {base: -3, sub1: 0, sub2: 1}, {base: -3, sub1: 1, sub2: -1},
                {base: -2, sub1: -1, sub2: 0}, {base: -2, sub1: 0, sub2: 1}, {base: -2, sub1: 1, sub2: -1},
                {base: -1, sub1: -1, sub2: 0}, {base: -1, sub1: 0, sub2: 1}, {base: -1, sub1: 1, sub2: -1},
                {base: 0, sub1: -1, sub2: 0}, {base: 0, sub1: 0, sub2: 1}, {base: 0, sub1: 1, sub2: -1},
                {base: 1, sub1: -1, sub2: 0}, {base: 1, sub1: 0, sub2: 1}, {base: 1, sub1: 1, sub2: -1},
                {base: 2, sub1: -1, sub2: 0}, {base: 2, sub1: 0, sub2: 1}, {base: 2, sub1: 1, sub2: -1},
                {base: 3, sub1: -1, sub2: 0}, {base: 3, sub1: 0, sub2: 1}, {base: 3, sub1: 1, sub2: -1},
                {base: 4, sub1: -1, sub2: 0}, {base: 4, sub1: 0, sub2: 1}, {base: 4, sub1: 1, sub2: -1},
                {base: 5, sub1: -1, sub2: 0}, {base: 5, sub1: 0, sub2: 1}, {base: 5, sub1: 1, sub2: -1}
            ];
            
            let nodeRadius = 4; // Even smaller
            
            // Draw massively dense pattern
            for (let i = 0; i < sampleB3Elements.length; i++) {
                let elem = sampleB3Elements[i];
                let baseY = centerY + elem.base * verticalSpacing + elem.sub1 * 8 + elem.sub2 * 4;
                
                // Show many 4-tuples for each, heavily overlapped and packed
                let subSubSubElements = [-2, -1, 0, 1, 2];
                for (let j = 0; j < subSubSubElements.length; j++) {
                    for (let k = 0; k < 4; k++) { // Even more overlapping instances
                        let y = baseY + j * 6 + k * 2 + (i % 7) * 1;
                        let xOffset = (j % 4) * 8 - 12 + k * 3 + (i % 3) * 2;
                        
                        // Only draw if within reasonable bounds
                        if (y > 90 && y < canvasHeight - 90 && Math.abs(xOffset) < 30) {
                            // Draw tiny circle
                            stroke(getStrokeColor());
                            strokeWeight(0.2);
                            fill(getBackgroundColor());
                            circle(x + xOffset, y, nodeRadius * 2);
                            
                            // Draw 4-tuple notation (tiny)
                            fill(getTextColor());
                            noStroke();
                            textSize(4);
                            text(`(${elem.base},${elem.sub1},${elem.sub2},${subSubSubElements[j]})`, x + xOffset, y);
                        }
                    }
                }
            }
            
            // Add ellipsis everywhere to show overwhelming density
            fill(getTextColor());
            noStroke();
            textSize(24);
            text('⋮', x, 85);
            text('⋮', x, canvasHeight - 85);
            text('⋮', x - 25, centerY - 50);
            text('⋮', x + 25, centerY - 50);
            text('⋮', x - 25, centerY + 50);
            text('⋮', x + 25, centerY + 50);
            text('⋮', x, centerY);
        }
        
        function drawArrowsToB4(x1, x2) {
            stroke(getStrokeColor());
            strokeWeight(0.1);
            drawingContext.setLineDash([1, 3]);
            
            // Draw just a few sample arrows due to extreme density
            for (let base of [-3, -1, 0, 1, 3]) {
                let baseY = centerY + base * verticalSpacing;
                
                // From B_3 elements to some B_4 elements
                for (let j of [0, 2, 4]) {
                    let y1 = baseY + j * 10;
                    let targetY = centerY + base * verticalSpacing + j * 8;
                    
                    // Draw spreading arrows
                    for (let spread = -20; spread <= 20; spread += 10) {
                        if (targetY + spread > 100 && targetY + spread < canvasHeight - 100) {
                            line(x1 + 8, y1, x2 - 6, targetY + spread);
                        }
                    }
                }
            }
            
            // Many arrows going completely off-screen
            for (let i = -5; i <= 5; i++) {
                if (i % 2 === 0) {
                    let baseY = centerY + i * verticalSpacing;
                    for (let offset = -30; offset <= 30; offset += 15) {
                        line(x1 + 8, baseY + offset, canvasWidth - 5, baseY + offset + Math.random() * 60 - 30);
                    }
                }
            }
            
            drawingContext.setLineDash([]);
        }
        
        
        function windowResized() {
            canvasWidth = min(windowWidth - 40, 1200);
            canvasHeight = min(windowHeight - 200, 800);
            resizeCanvas(canvasWidth, canvasHeight);
            centerY = canvasHeight / 2;
        }
    </script>
</body>
</html>